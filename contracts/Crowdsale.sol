//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

//import ierc20 interface from openzeppelin
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
//import SafeMath library from openzeppelin
import '@openzeppelin/contracts/utils/math/SafeMath.sol';
//import safeERC20 contract from openzeppelin
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';

contract Crowdsale {

    //use safemath for datatype uint256
    using SafeMath for uint256;

    //variable to store the address of token to use for crowdsale
    address public tokenAddress;

    //variable to store the address of owner where the funds generated by this crowdsale contract
    //will be transferred to
    address payable public walletAddress;

    //variable to store the rate at which token will be sold
    uint256 public rate;

    //varibale to store the owner of this contract
    address public owner;

    //variable to store the total amount of money sent to contract by buyers of tokens
    uint256 public amount;

    //enum to define the crowdsale stage
    enum CrowdsaleStage {preSale, seedSale, finalSale}

    //variable to store the initial stage of crowdsale
    //define the initial stage of crowdsale
    CrowdsaleStage public stage = CrowdsaleStage.preSale;

    //mapping of address to amount of tokens contributed in crowdsale
    mapping(address => uint) contributions;

    //event for purchasing tokens
    //first parameter is the account address calling the function
    //second parameter is the the buyer address to which tokens will be sent
    //third parameter is the amount sent to this crowdsale contract to buy tokens
    //fourth parameter is the total number of tokens sold to the buyer
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 indexed value, uint256 amount);

    //constructor to initialize the rate at which token will be sold,
    //the wallet address where the sent money to buy tokens will be stored,
    //the address of token which will be used for selling in this crowdsale
    constructor(address _walletAddress, uint256 _rate, address _tokenAddress){

        walletAddress = payable(_walletAddress);
        rate = _rate;
        tokenAddress = _tokenAddress;
        owner = msg.sender;
    }

    //function to check if the address to which tokens should be sent is not zero
    //and amount sent to buy the tokens is not zero
    function preValidatePurchase(address _beneficiary, uint256 _amount) internal {

        //address to which tokens should be sent should not be null
        require(_beneficiary != address(0));

        //amount sent to the contract for buying tokens should not be zero
        require(_amount != 0);

        //get the amount contributed by buyer before
        uint existingContribution = contributions[_beneficiary];

        //update the record
        contributions[_beneficiary] = existingContribution.add(amount);

    }

    //function to send tokens to an address from this crowdsale contract
    function sendTokens(address _beneficiary, uint256 _amount) internal {


        //send tokens from this crowdsale contract to the beneficiary
        IERC20(tokenAddress).transfer(_beneficiary, _amount);
    }

    //function to get the total number of tokens to
    //be sent to a address from this crowdsale contract
    //based on the money sent by the buyer
    function getTokenAmount(uint256 _amount) internal returns (uint256){

        return _amount.mul(rate);
    }

    //function to transfer funds by this crowdsale contract
    //to the owner account address
    function transferMoney() internal {

        //transfer the funds to owner account address
        walletAddress.transfer(msg.value);
    }

    //function to get the token balance
    function getTokenQuantity() internal returns (uint256) {

        return IERC20(tokenAddress).balanceOf(tokenAddress);
    }

    //function which will be called by users to buy
    //tokens from the crowdsale contract
    function buyTokens(address _beneficiary) public payable {

        //store the amount sent by the buyer to buy the tokens
        uint256 sentAmount = msg.value;

        //if token quantity is less than or equal to 30 million
        if (getTokenQuantity() <= 30000000) {

            //set crowd sale stage to presale
            setCrowdSaleStage(0);
        }
        //if token quantity is less than or equal to 50 million
        else if (getTokenQuantity() > 30000000 && getTokenQuantity() <= 50000000) {

            //set crowd sale stage to seed sale
            setCrowdSaleStage(1);
        }
        //for remaining tokens
        else {
            //set crowd sale stage to final sale
            setCrowdSaleStage(2);
        }

        //check the buyer address is not zero and
        //the amount sent to buy tokens is not zero
        preValidatePurchase(_beneficiary, sentAmount);


        //update the total funds generated by the crowdsale contract
        amount = amount.add(sentAmount);

        //calculate the amount of tokens to be sold to the buyer based on the money sent
        uint256 tokens = getTokenAmount(sentAmount);

        //send the tokens to the buyer
        sendTokens(_beneficiary, tokens);

        //transfer the funds from this crowdsale contract to owner's account
        transferMoney();

        //emit the token purchase event
        emit TokenPurchase(msg.sender, _beneficiary, sentAmount, tokens);
    }

    //function to get the amount sent by a buyer to this contract
    function getUserContribution(address _beneficiary) public view returns (uint256){

        //return the amount mapped to the address in contributions mapping
        return contributions[_beneficiary];
    }

    //modifier to check if caller is owner of token
    modifier onlyOwner(address _sender){

        //check if sender is the token owner
        require(owner == _sender, "you cannot call this method");
        _;
    }

    //function to set the stage of crowdsale
    function setCrowdSaleStage(uint _stage) public onlyOwner(msg.sender) {

        //if the passed stage is pre sale
        if (uint(CrowdsaleStage.preSale) == _stage) {

            //set the current stage to pre sale
            stage = CrowdsaleStage.preSale;

        }
        //if the passed stage is seed sale
        else if (uint(CrowdsaleStage.seedSale) == _stage) {

            //set the current stage to seed sale
            stage = CrowdsaleStage.seedSale;

        }
        //if the passed stage is final sale
        else {

            //set the current stage to final sale
            stage = CrowdsaleStage.finalSale;
        }

        //if current stage matches presale
        if (stage == CrowdsaleStage.preSale) {

            //set the rate to 500
            rate = 500;
        }

        //if the current stage matches seed sale
        else if (stage == CrowdsaleStage.seedSale) {

            //set the rate to 200
            rate = 200;
        }
        //if it is the final Sale
        else {
            rate;
        }

    }
}
